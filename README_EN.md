<div align="center">
  <img src="docs/media/logo.png" alt="yaml-mcp-server logo" width="120" height="120" />
  <h1>yaml-mcp-server</h1>
  <p>üîê MCP gateway with declarative YAML tools and a pluggable approval system for safe model actions.</p>
</div>

![Go Version](https://img.shields.io/github/go-mod/go-version/codex-k8s/yaml-mcp-server)
[![Go Reference](https://pkg.go.dev/badge/github.com/codex-k8s/yaml-mcp-server.svg)](https://pkg.go.dev/github.com/codex-k8s/yaml-mcp-server)

üá∑üá∫ –†—É—Å—Å–∫–∞—è –≤–µ—Ä—Å–∏—è: [README.md](README.md)

`yaml-mcp-server` is a single MCP server for a cluster that reads a YAML‚ÄëDSL to define tools and resources,
executes approver chains, and returns strictly structured responses.

## üéØ Idea and Motivation

The server enables **safe execution** of high‚Äërisk operations (secrets, repo settings, etc.) by requiring
explicit approval through pluggable approvers (HTTP/Shell/limits).

## ‚úÖ Key Features

- MCP server (HTTP/stdio) with tools created from YAML.
- Ordered approval chains per tool (limits ‚Üí shell ‚Üí HTTP, etc.).
- Strict response contract: `status`, `decision`, `reason`, `correlation_id`.
- Health endpoints: `/healthz`, `/readyz`.
- YAML templating with env checks before startup.

## üì¶ Installation

Go **>= 1.25.5** is required (see `go.mod`).

```bash
go install github.com/codex-k8s/yaml-mcp-server/cmd/yaml-mcp-server@latest
```

## üöÄ Quick Start

```bash
export YAML_MCP_CONFIG=/path/to/config.yaml
export YAML_MCP_LANG=en
export YAML_MCP_LOG_LEVEL=info

yaml-mcp-server
```

Default MCP HTTP endpoint: `http://localhost:8080/mcp`.

## üîå Connect to Codex (CLI/IDE)

Codex stores MCP configuration in `~/.codex/config.toml`. You can also scope it per project with `.codex/config.toml`
for trusted projects. The CLI and IDE extension share the same configuration.

### Option 1 ‚Äî via CLI

```bash
codex mcp add yaml-mcp-server --url http://localhost:8080/mcp
codex mcp list
```

After adding, make sure to set `tool_timeout_sec` in `config.toml` so Codex does not terminate long approval flows
on the client side (seconds).

### Option 2 ‚Äî via config.toml

```toml
[mcp_servers.yaml-mcp-server]
url = "http://localhost:8080/mcp"
tool_timeout_sec = 3600
```

If the server is deployed in a cluster, use an ingress/port‚Äëforward URL.

## üß© YAML‚ÄëDSL (short)

YAML defines server settings, tools, and resources. See `examples/`.

### Server

```yaml
server:
  name: yaml-mcp-server
  version: "0.1.0"
  transport: "http"   # http | stdio
  shutdown_timeout: "10s"
  startup_hooks:
    - timeout: "10s"
      command: |
        command -v gh >/dev/null
        command -v kubectl >/dev/null
    - timeout: "30s"
      command: |
        printf %s "$CODEXCTL_GH_PAT" | gh auth login --with-token
  http:
    listen: ":8080"
    path: "/mcp"
    read_timeout: "1h"
    write_timeout: "1h"
    idle_timeout: "1h"
```

### Tool

```yaml
tools:
  - name: GitHubSecretCreatorInK8s
    title: "Create GitHub secret and K8s secret"
    description: |
      Creates a GitHub environment secret and injects it into Kubernetes after approval.
      Input fields:
      - repo: repository in "owner/name" format.
      - secret_name: secret name (uppercase, digits, underscores).
      - environment: target environment, allowed values: ai-staging or staging.
      - namespace: Kubernetes namespace for secret injection.
      - k8s_secret_name: Kubernetes Secret name (kebab-case).
      - justification: required; write in Russian.
      The secret value is generated by the server, do NOT provide secret_value.
    requires_approval: true
    timeout: "1h"
    timeout_message: "approval timeout"
    input_schema:
      type: object
      additionalProperties: false
      required: ["repo", "secret_name", "environment", "namespace", "k8s_secret_name", "justification"]
      properties:
        repo: { type: string }
        secret_name: { type: string, pattern: "^[A-Z0-9_]+$" }
        environment: { type: string, enum: ["ai-staging", "staging"] }
        namespace: { type: string, pattern: "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$" } # DNS-1123
        k8s_secret_name: { type: string, pattern: "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$" } # DNS-1123
        justification: { type: string }
    approvers:
      - type: limits
        fields:
          secret_name: { regex: "^[A-Z0-9_]+$" }
          environment: { regex: "^(ai-staging|staging)$" }
          namespace: { regex: "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$" }
          k8s_secret_name: { regex: "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$" }
      - type: shell
        timeout: "1m"
        command: |
          if gh secret list -R {{ .Args.repo }} | awk '{print $1}' | grep -qx "{{ .Args.secret_name }}"; then
            echo "secret already exists"; exit 1; fi
    executor:
      type: shell
      timeout: "1h"
      command: |
        secret_value="$(head -c 32 /dev/urandom | base64)"
        gh api -X PUT "repos/{{ .Args.repo }}/environments/{{ .Args.environment }}" >/dev/null
        gh secret set {{ .Args.secret_name }} -R {{ .Args.repo }} --env {{ .Args.environment }} --body "$secret_value"
        kubectl -n {{ .Args.namespace }} create secret generic {{ .Args.k8s_secret_name }} \
          --from-literal={{ .Args.secret_name }}="$secret_value" \
          --dry-run=client -o yaml | kubectl apply -f -
        echo "secret {{ .Args.secret_name }} created in {{ .Args.repo }} env {{ .Args.environment }} and injected into {{ .Args.namespace }}/{{ .Args.k8s_secret_name }}"
```

### Resources

```yaml
resources:
  - name: Welcome
    uri: static:welcome
    description: Welcome message
    mime_type: text/plain
    text: "Hello from yaml-mcp-server"
```

## üîÑ End‚Äëto‚Äëend DB flow (GitHubSecretCreatorInK8s ‚Üí PsqlDbCreatorInK8s)

1) The model requests secrets such as `PG_USER` and `PG_PASSWORD` via `GitHubSecretCreatorInK8s`.
   Secrets are created in GitHub and **immediately injected** into Kubernetes.
2) The model calls `PsqlDbCreatorInK8s`, passing only secret names and keys:
   - `k8s_pg_user_secret_name` / `pg_user_secret_name`
   - `k8s_pg_password_secret_name` / `pg_password_secret_name`
3) The tool reads values from K8s secrets and creates the database inside the PostgreSQL pod.

### Benefits of this approach

- **The model never sees secret values**, but can still execute an approved workflow.
- **Secrets are immediately available** to services via Kubernetes Secret.
- **Unified approval chain and audit** through yaml-mcp-server.

### PsqlDbCreatorInK8s request example

```json
{
  "correlation_id": "corr-...",
  "tool": "PsqlDbCreatorInK8s",
  "arguments": {
    "namespace": "project-ai-staging",
    "db_name": "billing",
    "k8s_pg_user_secret_name": "db-credentials",
    "pg_user_secret_name": "PG_USER",
    "k8s_pg_password_secret_name": "db-credentials",
    "pg_password_secret_name": "PG_PASSWORD",
    "justification": "New database required for billing service"
  }
}
```

### Response example

```json
{
  "status": "success",
  "decision": "approve",
  "reason": "database billing created in namespace project-ai-staging",
  "correlation_id": "corr-..."
}
```

## üß™ Approvers

Supported approvers:

- `limits` ‚Äî rate limits and field validation (regex, min/max, length).
- `shell` ‚Äî approval based on a shell command.
- `http` ‚Äî approval via external HTTP service.

**Order is exactly as in YAML.** Chain stops on first `deny`.

### HTTP‚Äëapprover: request

```json
{
  "correlation_id": "corr-...",
  "tool": "GitHubSecretCreatorInK8s",
  "arguments": {
    "secret_name": "POSTGRES_PASSWORD",
    "environment": "ai-staging",
    "namespace": "project-ai-staging",
    "k8s_secret_name": "db-credentials"
  }
}
```

### HTTP‚Äëapprover: response

```json
{ "decision": "approve", "reason": "ok" }
```

`decision` is strictly one of: `approve | deny | error`.

## üì° Tool Response Protocol

```json
{
  "status": "success|denied|error",
  "decision": "approve|deny|error",
  "reason": "secret POSTGRES_PASSWORD created in owner/repo env ai-staging and injected into project-ai-staging/db-credentials",
  "correlation_id": "corr-..."
}
```

## üîß YAML templating

Available template functions:

- `env`, `envOr`, `default`, `ternary`, `join`, `lower`, `upper`, `trimPrefix`, `trimSuffix`, `replace`.

The server checks that all referenced env vars exist **before** startup.

## ‚ù§Ô∏è Health endpoints

- `GET /healthz` ‚Äî liveness
- `GET /readyz` ‚Äî readiness

## ‚öôÔ∏è Environment Variables

- `YAML_MCP_CONFIG` ‚Äî path to YAML config (default `config.yaml`).
- `YAML_MCP_LOG_LEVEL` ‚Äî `debug|info|warn|error`.
- `YAML_MCP_LANG` ‚Äî `en` (default) or `ru`.
- `YAML_MCP_SHUTDOWN_TIMEOUT` ‚Äî graceful shutdown timeout.

## üìÑ Examples

- `examples/combined_tools_shell_http.yaml`
  (contains two tools: GitHubSecretCreatorInK8s and PsqlDbCreatorInK8s)

## üß∑ Security notes

`yaml-mcp-server` is a **general MCP gateway** that isolates risky actions from the model and only allows execution
through explicit approval. The GitHub secret flow is just an example: the model does not know tokens or secret values,
but can request creation via an approved flow.

There is **no built-in access control yet**. Run the service either locally or in a cluster with strict network access
restrictions to the `yaml-mcp-server`.
